importScripts(\"./lib/URI.min.js\");\n\nconst c_enabledIcons = {\n\n16: \"images/icon16.png\",\n\n24: \"images/icon24.png\",\n\n32: \"images/icon32.png\"\n\n};\n\nconst c_disabledIcons = {\n\n16: \"images/iconDisabled16.png\",\n\n24: \"images/iconDisabled24.png\",\n\n32: \"images/iconDisabled32.png\"\n\n};\n\n// Default settings configuration\n\nconst DEFAULT_SETTINGS = {\n\nexceptions: [\"mail.google.com\", \"gmail.com\"],\n\nisWhitelist: false, // Default to Blacklist mode, which is more common\n\nfilterForms: true,\n\nenabled: true\n\n};\n\n// Performance caching\n\nconst cache = {\n\nstorage: new Map(), // Maps individual storage keys to their values\n\nprocessedExceptions: null // Cache for processed exceptions array\n\n};\n\n// Cached storage operations\n\nasync function getCachedStorage(keys) {\n\nconst keyArray = Array.isArray(keys) ? keys : [keys];\n\nconst result = {};\n\nconst uncachedKeys = [];\n\nfor (const key of keyArray) {\n\nif (cache.storage.has(key)) {\n\nresult[key] = cache.storage.get(key);\n\n} else {\n\nuncachedKeys.push(key);\n\n}\n\n}\n\nif (uncachedKeys.length > 0) {\n\n// Set default values for any keys not found in storage\n\nconst defaultsToFetch = {};\n\nuncachedKeys.forEach(key => {\n\nif (DEFAULT_SETTINGS.hasOwnProperty(key)) {\n\ndefaultsToFetch[key] = DEFAULT_SETTINGS[key];\n\n}\n\n});\n\nconst fetchedData = await chrome.storage.sync.get(defaultsToFetch);\n\nfor (const key of uncachedKeys) {\n\nconst value = fetchedData[key];\n\ncache.storage.set(key, value);\n\nresult[key] = value;\n\n}\n\n}\n\nreturn result;\n\n}\n\n// Invalidate storage cache\n\nfunction invalidateStorageCache(specificKeys = null) {\n\nif (specificKeys) {\n\nconst keysToInvalidate = Array.isArray(specificKeys) ? specificKeys : [specificKeys];\n\nfor (const key of keysToInvalidate) {\n\ncache.storage.delete(key);\n\nif (key === \'exceptions\' || key === \'isWhitelist\') {\n\ncache.processedExceptions = null;\n\n}\n\n}\n\n} else {\n\ncache.storage.clear();\n\ncache.processedExceptions = null;\n\n}\n\n}\n\nasync function updateButtonState() {\n\ntry {\n\nconst {enabled} = await getCachedStorage(\"enabled\");\n\nawait chrome.action.setIcon({path: enabled ? c_enabledIcons : c_disabledIcons});\n\n} catch (error) {\n\nconsole.error(\"Error updating button state:\", error);\n\n}\n\n}\n\nasync function getExceptions() {\n\ntry {\n\nif (cache.processedExceptions !== null) {\n\nreturn cache.processedExceptions;\n\n}\n\nconst {exceptions} = await getCachedStorage(\"exceptions\");\n\nif (!exceptions || !Array.isArray(exceptions)) {\n\ncache.processedExceptions = [];\n\nreturn [];\n\n}\n\nconst processedExceptions = exceptions\n\n.map(e => e.trim())\n\n.filter(e => e !== \"\")\n\n.map(e => e.replace(/[.*+?^${}()|[\]\\]/g, \'\\\\$&\'))\n\n.map(e => new RegExp(\"(.|^)\" + e + \"$\"));\n\ncache.processedExceptions = processedExceptions;\n\nreturn processedExceptions;\n\n} catch (error) {\n\nconsole.error(\"Error getting exceptions:\", error);\n\nreturn [];\n\n}\n\n}\n\nasync function shouldFilterPage(uri) {\n\ntry {\n\nconst { isWhitelist } = await getCachedStorage(\"isWhitelist\");\n\nconst exceptions = await getExceptions();\n\nconst domain = new URI(uri).hostname();\n\nconst isMatch = exceptions.some(e => e.test(domain));\n\nif (isWhitelist) {\n\n// WHITELIST MODE: Only filter if the domain IS on the list.\n\nreturn isMatch;\n\n} else {\n\n// BLACKLIST MODE: Filter unless the domain is on the list.\n\nreturn !isMatch;\n\n}\n\n} catch (error) {\n\nconsole.error(\"Error checking if page should be filtered:\", error);\n\nreturn true; // Default to filtering on error for security\n\n}\n\n}\n\nasync function filterPage(uri) {\n\nconst {enabled, filterForms} = await getCachedStorage([\"enabled\", \"filterForms\"]);\n\nif (!enabled) {\n\nreturn { shouldFilter: false };\n\n}\n\nconst shouldFilter = await shouldFilterPage(uri);\n\nif (shouldFilter) {\n\nreturn { shouldFilter: true, filterForms: filterForms };\n\n}\n\nreturn { shouldFilter: false };\n\n}\n\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n\nif (request.method === \"shouldFilterPage\") {\n\nfilterPage(request.URI).then(sendResponse);\n\n} else if (request.method === \"updateButtonState\") {\n\nupdateButtonState().then(() => sendResponse({}));\n\n} else {\n\nsendResponse({});\n\n}\n\nreturn true;\n\n});\n\nchrome.action.onClicked.addListener(async function (tab) {\n\ntry {\n\nconst {enabled} = await getCachedStorage(\"enabled\");\n\nawait chrome.storage.sync.set({enabled: !enabled});\n\ninvalidateStorageCache(\"enabled\");\n\nawait updateButtonState();\n\n} catch (error) {\n\nconsole.error(\"Error toggling extension state:\", error);\n\n}\n\n});\n\nchrome.runtime.onInstalled.addListener((details) => {\n\nif (details.reason === \"install\") {\n\nchrome.storage.sync.set(DEFAULT_SETTINGS, () => {\n\ninvalidateStorageCache();\n\nupdateButtonState();\n\n});\n\n} else if (details.reason === \"update\") {\n\nupdateButtonState().catch(console.error);\n\n}\n\n});\n\nchrome.storage.onChanged.addListener((changes, namespace) => {\n\nif (namespace === \'sync\') {\n\nconst changedKeys = Object.keys(changes);\n\ninvalidateStorageCache(changedKeys);\n\n}\n\n});\n\nupdateButtonState().catch(console.error);